package;

import flash.display.BitmapData;
import flixel.FlxG;
import flixel.FlxObject;
import flixel.FlxSprite;

class Spike extends FlxSprite
{
	/**
	 * Internal storage for the programmatically generated pixel data so we only have to make it once.
	 */
	private static var _storedPixels:BitmapData;
	
	/**
	 * Programmatically generates a new bunch o' spikes for the top or bottom of the screen.
	 * 
	 * @param	IsTop	If true, this sprite is flipped on the Y-axis.
	 */
	public function new(IsTop:Bool = true)
	{
		super(0, IsTop ? 0 : FlxG.height - 16);
		
		// If we haven't generated the spikes yet, we need to do that.
		// Spikes are generated by code so that no matter the user's device width, an appropriately-sized graphic is available.
		
		if (_storedPixels == null)
		{
			// Generate a clear graphic which we will stamp other graphics onto.
			
			makeGraphic(FlxG.width, 16, 0);
			
			// The left side of the spike graphic.
			
			var left:FlxSprite = new FlxSprite(0, 0, "assets/spike_left.png");
			
			// The bottom of the spike graphic. Repeated as necessary to fill the screen width.
			
			var bottom:FlxSprite = new FlxSprite(0, 0, "assets/spike_bottom.png");
			var xPos:Int = Std.int(left.width);
			
			while (xPos < FlxG.width)
			{
				stamp(bottom, xPos, 8);
				xPos += Std.int(bottom.width);
			}
			
			// The right side of the spike graphic
			
			var right:FlxSprite = new FlxSprite(0, 0, "assets/spike_right.png");
			
			// The actual spikes. Repeated as necessary to fill the graphic.
			
			var top:FlxSprite = new FlxSprite(0, 0, "assets/spike_top.png");
			
			// A small offset from the left to make the spikes look a bit better.
			
			xPos = 2;
			
			while (xPos < FlxG.width)
			{
				stamp(top, xPos, 0);
				xPos += Std.int(top.width);
			}
			
			// Stamp the left and right side graphics on top of everything else.
			
			stamp(left, 0, 0);
			stamp(right, Std.int(FlxG.width - right.width), 0);
			
			// Store the generated graphics so they can be re-used later (by the other spike object).
			
			_storedPixels = pixels;
		}
		else
		{
			// We've already generated an appropriate graphic, let's just use it again.
			
			loadGraphic(_storedPixels);
		}
		
		// Finally, flip the object if it's on top.
		
		setFacingFlip(FlxObject.DOWN, false, true);
		
		if (IsTop)
		{
			facing = FlxObject.DOWN;
		}
	}
}